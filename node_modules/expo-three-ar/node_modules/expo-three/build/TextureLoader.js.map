{"version":3,"file":"TextureLoader.js","sourceRoot":"","sources":["../src/TextureLoader.ts"],"names":[],"mappings":"AAAA,OAAO,UAAU,MAAM,kBAAkB,CAAC;AAC1C,OAAO,KAAK,MAAM,SAAS,CAAC;AAC5B,OAAO,EAAE,QAAQ,EAAE,MAAM,kBAAkB,CAAC;AAE5C,oFAAoF;AACpF,SAAS,aAAa,CAAC,GAAW;IAChC,MAAM,MAAM,GACV,GAAG,CAAC,MAAM,CAAC,gBAAgB,CAAC,GAAG,CAAC,IAAI,GAAG,CAAC,MAAM,CAAC,oBAAoB,CAAC,KAAK,CAAC,CAAC;IAE7E,OAAO,MAAM,CAAC,CAAC,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,KAAK,CAAC,UAAU,CAAC;AACrD,CAAC;AAED,MAAM,CAAC,OAAO,OAAO,iBAAkB,SAAQ,KAAK,CAAC,aAAa;IAChE,IAAI,CACF,KAAU,EACV,MAAyC,EACzC,UAA2C,EAC3C,OAAqC;QAErC,IAAI,CAAC,KAAK,EAAE;YACV,MAAM,IAAI,KAAK,CACb,2DAA2D,CAC5D,CAAC;SACH;QAED,IAAI,OAAO,GAAG,IAAI,KAAK,CAAC,OAAO,EAAE,CAAC;QAElC,MAAM,MAAM,GAAG,IAAI,KAAK,CAAC,WAAW,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QACnD,MAAM,CAAC,cAAc,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;QACxC,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAE1B,CAAC,KAAK,IAAI,EAAE;YACV,MAAM,WAAW,GAAG,MAAM,UAAU,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC;YAEzD,SAAS,UAAU,CAAC,KAAK;gBACvB,OAAO,CAAC,KAAK,GAAG,KAAK,CAAC;gBAEtB,oFAAoF;gBACpF,OAAO,CAAC,MAAM,GAAG,aAAa,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;gBACrD,OAAO,CAAC,WAAW,GAAG,IAAI,CAAC;gBAE3B,IAAI,MAAM,KAAK,SAAS,EAAE;oBACxB,MAAM,CAAC,OAAO,CAAC,CAAC;iBACjB;YACH,CAAC;YAED,IAAI,QAAQ,CAAC,EAAE,KAAK,KAAK,EAAE;gBACzB,MAAM,CAAC,IAAI,CACT,WAAW,CAAC,QAAQ,EACpB,KAAK,CAAC,EAAE;oBACN,UAAU,CAAC,KAAK,CAAC,CAAC;gBACpB,CAAC,EACD,UAAU,EACV,OAAO,CACR,CAAC;aACH;iBAAM;gBACL,OAAO,CAAC,eAAe,CAAC,GAAG,IAAI,CAAC,CAAC,kDAAkD;gBACnF,OAAO,CAAC,SAAS,GAAG,KAAK,CAAC,YAAY,CAAC,CAAC,gCAAgC;gBAExE,UAAU,CAAC;oBACT,IAAI,EAAE,WAAW;oBACjB,KAAK,EAAE,WAAW,CAAC,KAAK;oBACxB,MAAM,EAAE,WAAW,CAAC,MAAM;iBAC3B,CAAC,CAAC;aACJ;QACH,CAAC,CAAC,EAAE,CAAC;QAEL,OAAO,OAAO,CAAC;IACjB,CAAC;CACF","sourcesContent":["import AssetUtils from 'expo-asset-utils';\nimport THREE from './Three';\nimport { Platform } from '@unimodules/core';\n\n// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.\nfunction formatFromURI(uri: string) {\n  const isJPEG =\n    uri.search(/\\.jpe?g($|\\?)/i) > 0 || uri.search(/^data\\:image\\/jpeg/) === 0;\n\n  return isJPEG ? THREE.RGBFormat : THREE.RGBAFormat;\n}\n\nexport default class ExpoTextureLoader extends THREE.TextureLoader {\n  load(\n    asset: any,\n    onLoad?: (texture: THREE.Texture) => void,\n    onProgress?: (event: ProgressEvent) => void,\n    onError?: (event: ErrorEvent) => void,\n  ): THREE.Texture {\n    if (!asset) {\n      throw new Error(\n        'ExpoTHREE.TextureLoader.load(): Cannot parse a null asset',\n      );\n    }\n\n    let texture = new THREE.Texture();\n\n    const loader = new THREE.ImageLoader(this.manager);\n    loader.setCrossOrigin(this.crossOrigin);\n    loader.setPath(this.path);\n\n    (async () => {\n      const nativeAsset = await AssetUtils.resolveAsync(asset);\n\n      function parseAsset(image) {\n        texture.image = image;\n\n        // JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.\n        texture.format = formatFromURI(nativeAsset.localUri);\n        texture.needsUpdate = true;\n\n        if (onLoad !== undefined) {\n          onLoad(texture);\n        }\n      }\n\n      if (Platform.OS === 'web') {\n        loader.load(\n          nativeAsset.localUri,\n          image => {\n            parseAsset(image);\n          },\n          onProgress,\n          onError,\n        );\n      } else {\n        texture['isDataTexture'] = true; // Forces passing to `gl.texImage2D(...)` verbatim\n        texture.minFilter = THREE.LinearFilter; // Pass-through non-power-of-two\n\n        parseAsset({\n          data: nativeAsset,\n          width: nativeAsset.width,\n          height: nativeAsset.height,\n        });\n      }\n    })();\n\n    return texture;\n  }\n}\n"]}