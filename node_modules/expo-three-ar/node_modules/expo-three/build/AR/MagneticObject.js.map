{"version":3,"file":"MagneticObject.js","sourceRoot":"","sources":["../../src/AR/MagneticObject.ts"],"names":[],"mappings":"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","sourcesContent":["import { AR } from 'expo';\nimport THREE from '../Three';\nimport { positionFromTransform, worldPositionFromScreenPosition } from './calculations';\nimport ARCamera from './Camera';\n// TODO: Bacon: Vertical support\n\nclass MagneticObject extends THREE.Object3D {\n  // use average of recent positions to avoid jitter\n  recentMagneticPositions: any[] = [];\n  anchorsOfVisitedPlanes: any[] = [];\n\n  maintainScale = true;\n  maintainRotation = true;\n\n  constructor() {\n    super();\n  }\n\n  updateForAnchor = (\n    position: THREE.Vector3,\n    planeAnchor: AR.PlaneAnchor | null,\n    camera: THREE.Camera\n  ) => {\n    if (planeAnchor != null) {\n      // const index = this.anchorsOfVisitedPlanes.indexOf(planeAnchor);\n      this.anchorsOfVisitedPlanes.unshift(planeAnchor);\n      // TODO: Move in direction\n      // this.visible = false;\n    } else {\n      // this.visible = true;\n    }\n    this.updateTransform(position, camera);\n  };\n\n  update = (camera: ARCamera, screenPosition): void => {\n    const data = worldPositionFromScreenPosition(camera, screenPosition, this.position);\n    if (data && data.worldPosition) {\n      this.updateForAnchor(data.worldPosition, data.planeAnchor, camera);\n    }\n  };\n\n  isValidVector = vector => vector && !isNaN(vector.x) && !isNaN(vector.y) && !isNaN(vector.z);\n\n  updateTransform = (position, camera) => {\n    if (!this.isValidVector(position)) {\n      return;\n    }\n    // add to list of recent positions\n    this.recentMagneticPositions.push(position);\n\n    // remove anything older than the last 8\n    while (this.recentMagneticPositions.length > 8) {\n      this.recentMagneticPositions.shift();\n    }\n\n    // move to average of recent positions to avoid jitter\n\n    if (this.recentMagneticPositions.length > 4) {\n      const { length } = this.recentMagneticPositions;\n      let average = new THREE.Vector3();\n\n      for (let position of this.recentMagneticPositions) {\n        average.add(position);\n      }\n      average.divide(new THREE.Vector3(length, length, length));\n      this.position.set(average.x, average.y, average.z);\n\n      if (this.maintainScale) {\n        const scale = this.scaleBasedOnDistance(camera);\n        this.scale.set(scale, scale, scale);\n      } else {\n        this.scale.set(1, 1, 1);\n      }\n    }\n\n    if (this.maintainRotation) {\n      // Correct y rotation of camera square\n      if (camera) {\n        let cameraQuaternion = new THREE.Quaternion();\n        camera.getWorldQuaternion(cameraQuaternion);\n\n        let cameraEuler = new THREE.Euler();\n        cameraEuler.setFromQuaternion(cameraQuaternion, 'YZX');\n\n        const tilt = Math.abs(cameraEuler.x);\n        const threshold1 = (Math.PI / 2) * 0.65;\n        const threshold2 = (Math.PI / 2) * 0.75;\n        const yaw = Math.atan2(camera.matrixWorld.elements[0], camera.matrixWorld.elements[1]);\n        let angle = 0;\n\n        if (tilt >= 0 || tilt < threshold1) {\n          angle = cameraEuler.y;\n        } else if (tilt >= threshold1 || tilt < threshold2) {\n          const relativeInRange = Math.abs((tilt - threshold1) / (threshold2 - threshold1));\n          const normalizedY = this.normalize(cameraEuler.y, yaw);\n          angle = normalizedY * (1 - relativeInRange) + yaw * relativeInRange;\n        } else {\n          angle = yaw;\n        }\n        this.setRotationFromAxisAngle(new THREE.Vector3(0, 1, 0), angle);\n      }\n    }\n  };\n\n  normalize = (angle: number, ref: number) => {\n    // Normalize angle in steps of 90 degrees such that the rotation to the other angle is minimal\n    let normalized = angle;\n    while (Math.abs(normalized - ref) > Math.PI / 4) {\n      if (angle > ref) {\n        normalized -= Math.PI / 2;\n      } else {\n        normalized += Math.PI / 2;\n      }\n    }\n    return normalized;\n  };\n\n  get worldPosition(): THREE.Vector3 {\n    let worldPosition = new THREE.Vector3();\n    this.getWorldPosition(worldPosition);\n    return worldPosition;\n  }\n\n  scaleBasedOnDistance = (camera): number => {\n    if (camera) {\n      const cameraPosition = positionFromTransform(camera.matrixWorld);\n\n      const delta = this.position.clone().sub(cameraPosition);\n      let distanceFromCamera = delta.length();\n      // console.log('distanceFromCamera', cameraPosition, this.position, distanceFromCamera);\n\n      // From Apple:\n      // Reduce size changes of the node based on the distance by scaling it up if it is far away,\n      // and down if it is very close.\n      // The values are adjusted such that scale will be 1 in 0.7 m distance (estimated distance when looking at a table),\n      // and 1.2 in 1.5 m distance (estimated distance when looking at the floor).\n      const newScale =\n        distanceFromCamera < 0.7 ? distanceFromCamera / 0.7 : 0.25 * distanceFromCamera + 0.825;\n\n      return newScale;\n    }\n    return 1.0;\n  };\n}\n\nexport default MagneticObject;\n"]}